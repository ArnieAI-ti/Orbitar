<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animated Background</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #121826;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="particles-js"></canvas>
  <script>
    const canvas = document.getElementById('particles-js');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particlesArray;
    let chaosModeActive = false;
    let chaosModeTimer = 0;
    const chaosModeDuration = 10000; // 10 seconds in milliseconds
    const normalModeDuration = 5000; // 5 seconds in milliseconds (adjust as needed)

    // get mouse position
    let mouse = {
      x: null,
      y: null,
      radius: (canvas.height/80) * (canvas.width/80)
    }

    window.addEventListener('mousemove', 
      function(event) {
        mouse.x = event.x;
        mouse.y = event.y;
      }
    );

    

    // create particle
    class Particle {
      constructor(x, y, directionX, directionY, size, color) {
        this.x = x;
        this.y = y;
        this.directionX = directionX;
        this.directionY = directionY;
        this.size = size;
        this.color = color;
      }
      // method to draw individual particle
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
        ctx.fillStyle = '#61DAFB';
        ctx.fill();
      }
      // check particle position, check mouse position, move the particle, draw the particle
      update() {
        // check if particle is still within canvas
        if (this.x > canvas.width - this.size || this.x < this.size) {
          this.directionX = -this.directionX;
        }
        if (this.y > canvas.height - this.size || this.y < this.size) {
          this.directionY = -this.directionY;
        }

        // Calculate center of the canvas
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Apply central pull and tangential force
        let vecX = centerX - this.x;
        let vecY = centerY - this.y;
        let distanceToCenter = Math.sqrt(vecX * vecX + vecY * vecY);
        if (distanceToCenter > 0) {
          vecX /= distanceToCenter;
          vecY /= distanceToCenter;
        }
        const centralPullStrength = 0.001; // Further reduced for less rigidity
        this.directionX += vecX * centralPullStrength;
        this.directionY += vecY * centralPullStrength;

        const tangentialStrength = 0.005; // Further reduced for less rigidity
        this.directionX += -vecY * tangentialStrength;
        this.directionY += vecX * tangentialStrength;

        // Apply attraction between particles
        const attractionStrength = 0.001; // Reduced for less inter-particle attraction
        for (let i = 0; i < particlesArray.length; i++) {
          const otherParticle = particlesArray[i];
          if (otherParticle === this) continue;

          let dx = otherParticle.x - this.x;
          let dy = otherParticle.y - this.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 150 && distance > 0) { // Only attract if close enough and not same particle
            let force = attractionStrength * (otherParticle.size / (distance * distance));
            this.directionX += dx * force;
            this.directionY += dy * force;
          }
        }

        // Limit speed to prevent particles from accelerating too much
        // Apply mouse force if mouse is active and chaos mode is not active
        if (!chaosModeActive && mouse.x && mouse.y) {
          let mouseVecX = mouse.x - this.x;
          let mouseVecY = mouse.y - this.y;
          let distanceToMouse = Math.sqrt(mouseVecX * mouseVecX + mouseVecY * mouseVecY);

          if (distanceToMouse < mouse.radius) {
            if (distanceToMouse > 0) {
              mouseVecX /= distanceToMouse;
              mouseVecY /= distanceToMouse;
            }
            const mouseAttractionStrength = 0.1; // Adjust for mouse attraction
            this.directionX += mouseVecX * mouseAttractionStrength;
            this.directionY += mouseVecY * mouseAttractionStrength;

            const mouseTangentialStrength = 0.2; // Adjust for mouse tangential force
            this.directionX += -mouseVecY * mouseTangentialStrength;
            this.directionY += mouseVecX * mouseTangentialStrength;
          }
        }

        // Limit speed to prevent particles from accelerating too much
        const maxSpeed = 1.5; // Further reduced max speed
        let currentSpeed = Math.sqrt(this.directionX * this.directionX + this.directionY * this.directionY);
        if (currentSpeed > maxSpeed) {
          this.directionX = (this.directionX / currentSpeed) * maxSpeed;
          this.directionY = (this.directionY / currentSpeed) * maxSpeed;
        }

        // move particle
        this.x += this.directionX;
        this.y += this.directionY;
        // draw particle
        this.draw();
      }
    }

    // create particle array
    function init() {
      particlesArray = [];
      let numberOfParticles = (canvas.height * canvas.width) / 5000; // Aumentado el número de partículas
      for (let i = 0; i < numberOfParticles; i++) {
        let size = (Math.random() * 5) + 1;
        let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
        let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
        let directionX = (Math.random() * 5) - 2.5;
        let directionY = (Math.random() * 5) - 2.5;
        let color = '#61DAFB';

        particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
      }
    }

    // animation loop
    let lastTime = 0;
    function animate(currentTime) {
      requestAnimationFrame(animate);
      ctx.clearRect(0,0,innerWidth, innerHeight);

      if (!lastTime) lastTime = currentTime;
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      chaosModeTimer += deltaTime;

      if (chaosModeActive) {
        if (chaosModeTimer >= chaosModeDuration) {
          chaosModeActive = false;
          chaosModeTimer = 0;
        }
      } else {
        if (chaosModeTimer >= normalModeDuration) {
          chaosModeActive = true;
          chaosModeTimer = 0;
        }
      }

      for (let i = 0; i < particlesArray.length; i++){
        particlesArray[i].update();
      }
      connect();
    }

    // check if particles are close enough to draw line between them
    function connect(){
      let opacityValue = 1;
      for (let a = 0; a < particlesArray.length; a++) {
        for (let b = a; b < particlesArray.length; b++) {
          let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))
          + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
          if (distance < (canvas.width/7) * (canvas.height/7)) {
            opacityValue = 1 - (distance/20000);
            ctx.strokeStyle='rgba(97,218,251,' + opacityValue + ')';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
            ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
            ctx.stroke();
          }
        }
      }
    }

    // resize event
    window.addEventListener('resize', 
      function(){
        canvas.width = innerWidth;
        canvas.height = innerHeight;
        mouse.radius = ((canvas.height/80) * (canvas.height/80));
        init();
      }
    );

    // mouse out event
    window.addEventListener('mouseout', 
      function(){
        mouse.x = undefined;
        mouse.y = undefined;
      }
    )

    init();
    animate();
  </script>
</body>
</html>
